<!doctype html>
<html>
  <head>
    <style>
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  background-color: #000;
  /* color: #F5F5F5; */
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;
  // font-weight: 300;
}
.body {
  display: flex;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}
header {
  position: absolute;
  display: flex;
  top: 0;
  left: 0;
  width: 100vw;
  height: 50px;
  background-color: #FFF;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
  align-items: center;
  user-select: none;
  z-index: 1;
}
header img {
  width: 50px;
  height: 50px;
  margin: 0 20px;
}
header nav {
  display: flex;
  height: 100%;
  padding: 0 10px;
  letter-spacing: 0.9px;
  align-items: center;
  text-transform: uppercase;
}
header nav span {
  display: flex;
  height: 30px;
  padding: 10px;
  border-radius: 4px;
  align-items: center;
}
header nav.selected span {
  background-color: #5c6bc0;
  color: #FFF;
  cursor: default;
}
header nav:not(.selected):hover {
  cursor: pointer;
}
header nav:not(.selected):hover span {
  background-color: #EEE;
}
.examples {
  width: 200px;
  padding-top: 50px;
  background-color: #FFF;
}
h1, h2, h3, h4, h5, h6, p, .examples > .multibutton {
  margin: 20px 0;
  padding: 0 20px;
  font-weight: inherit;
}
li {
  /* padding-left: 20px;
  padding-right: 20px; */
}
.iframe-wrapper {
  position: relative;
  display: flex;
  margin-top: 50px;
  flex: 1;
  background-color: #FFF;
}
.tabs {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}
.tabs .tab {
  display: inline-flex;
  margin: 5px 5px;
  padding: 5px 10px;
  background-color: #D8D8D8;
  border-radius: 4px;
  color: #000;
  align-items: center;
}
.tabs .tab .text {
  margin-right: 10px;
  align-items: center;
}
.tabs .tab .close-x {
  display: flex;
  width: 20px;
  height: 20px;
  background-color: #ef5350;
  color: #FFF;
  justify-content: center;
  align-items: center;
}
canvas {
  width: 100% !important;
  height: 100vh !important;
  background-color: #f8f8f8;
}
a {
  color: #AAA;
  text-decoration: none;
}
a:hover {
  color: #42a5f5;
}
a:active {
  color: #1976d2;
}
.body > .multibutton {
  position: absolute;
  right: 30px;
  bottom: 30px;
}
.multibutton {
  display: flex;
}
.multibutton .button:not(.first) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.multibutton .button:not(.last) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.button {
  display: inline-flex;
  margin-right: 5px;
  padding: 8px 20px;
  border: 2px solid;
  border-radius: 100px;
  color: #5c6bc0;
  cursor: pointer;
}
/* .button:not(:last-child) {
  margin-right: 20px;
} */
.button:not([disabled]):hover {
  background-color: #5c6bc0;
  border-color: #5c6bc0;
  color: #FFF;
}
.button[disabled] {
  color: #b71c1c;
  cursor: auto;
}
#code-header:not(.open),
#code-button:not(.open) .opened-text,
#code-button.open .closed-text
{
  display: none;
}
.coming-soon {
  color: #ccc;
}
.coming-soon-sub {
  font-size: 10px;
  display: block;
}
.header-link {
  color: #666;
}
.code-header {
  position: absolute;
  top: 50px;
  right: 0;
  display: flex;
  align-items: center;
  width: 600px;
  height: 32px;
  padding: 5px;
  font-size: 13px;
  color: #4caf50;
  background-color: #f2f3f5;
}
.code {
  position: absolute;
  top: 82px;
  bottom: 0;
  right: 0;
  width: 600px;
  border: 0;
  border-left: 5px solid #f2f3f5;
  outline: none;
}
.code:not(.open) {
  display: none;
}
input[type=text] {
  width: 160px;
  margin: 0 20px;
  padding: 7px 15px;
  background-color: #f2f3f5;
  border: 0;
  border-radius: 8px;
  font-family: inherit;
  font-size: inherit;
  outline: none;
}
    </style>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="FBXLoader.js"></script>
    <script src="inflate.min.js"></script>
    <script src="Reflector.js"></script>
    <script src="gunzip.min.js"></script>
    <script src="ProgressivePromise.js"></script>
    <script src="untar.js"></script>
    <script src="zip.js"></script>
    <script src="bmfont.js"></script>
    <script src="https://multiplayer.exokit.org/multiplayer.js"></script>
  </head>
  <body>
    <div class=body>
      <header>
        <img src="logo.svg">
        <nav class=selected><span>Avatars</span></nav>
        <!-- <a href="https://docs.exokit.org/"><nav><span class="header-link">Documentation</span></nav></a>
        <a href="https://browser.exokit.org"><nav><span class="header-link">Browser
        </span></nav></a>
        <a href="https://discord.gg/UgZDFZW"><nav><span class="coming-soon">Exoland
          <p class="coming-soon-sub">Coming soon!</p>
        </span></nav></a> -->
      </header>

      <div class=examples>
        <h3>Examples</h3>
        <p>
          <a href="https://exokitxr.github.io/avatar-models/model.glb" class="a-avatar">model.glb</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model2.vrm" class="a-avatar">model2.vrm</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model3.unitypackage" class="a-avatar">model3.unitypackage</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model4.zip" class="a-avatar">model4.zip</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model5.fbx" class="a-avatar">model5.fbx</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model6.zip" class="a-avatar">model6.zip</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model7.vrm" class="a-avatar">model7.vrm</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model8.vrm" class="a-avatar">model8.vrm</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model9.vrm" class="a-avatar">model9.vrm</a><br>
        </p>
        <div class=multibutton>
          <label for="upload-file-button">
            <a class="button first last">Upload file...</a>
            <input type="file" id="upload-file-button" style="display: none">
          </label>
        </div>
        <h3>Multiplayer</h3>
        <input type=text value="avaer/yatis" placeholder="user/channel" id=channel-input>
        <div class=multibutton>
          <nav class="button first last" id=connect-button>Connect</nav>
        </div>
      </div>

      <div class=iframe-wrapper id=iframe-wrapper></div>

      <div class=multibutton>
        <a class="button first" id="enable-mic-button" style="display: none;">Enable Mic</a>
        <a class="button first" id="disable-mic-button" disabled style="display: none;">Disable Mic</a>
        <a class="button last" id="enter-xr-button" style="display: none;">Enter XR</a>
        <a class="button last" id="no-xr-button" disabled style="display: none;">No XR</a>
      </div>
    </div>
    <script type=module>
import './webxr-polyfill.module.js';
import './HelioWebXRPolyfill.js';
import Avatar from './vrarmik/avatars.js';

const peerPoseUpdateRate = 50;
const floorPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0));

const localVector = new THREE.Vector3();
const localVector2 = new THREE.Vector3();
const localVector3 = new THREE.Vector3();
const localQuaternion = new THREE.Quaternion();
const localEuler = new THREE.Euler();
const localRay = new THREE.Ray();

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.y = 1.5;
camera.position.z = 2;
// camera.rotation.y = Math.PI;

const cameraDolly = new THREE.Object3D();
// cameraDolly.add(camera);

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
directionalLight.position.set(0.5, 1, 0.5);
scene.add(directionalLight);

/* const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 1);
directionalLight2.position.set(0, -0.25, -0.25);
scene.add(directionalLight2); */

const gridHelper = new THREE.GridHelper(10, 10);
scene.add(gridHelper);

const cubeGeometry = new THREE.ConeBufferGeometry(0.05, 0.2, 3)
  .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)))
  );
const materials ={};
const _getCubeMaterial = color => {
  let material = materials[color];
  if (!material) {
    material = new THREE.MeshPhongMaterial({
      color,
      flatShading: true,
    });
    materials[color] = material;
  }
  return material;
}
const _makeCubeMesh = (color = 0x0000FF) => {
  const mesh = new THREE.Mesh(cubeGeometry, _getCubeMaterial(color));
  mesh.frustumCulled = false;
  if (color === 0x008000 || color === 0x808000) {
    // mesh.add(new THREE.AxesHelper());
  }
  return mesh;
};
const _makeTextMesh = (s = '', color = 0x000000, size = 1) => {
  // create a geometry of packed bitmap glyphs,
  // word wrapped to 300px and right-aligned
  var geometry = createTextGeometry({
    width: Infinity,
    font: fontJson,
  });

  // change text and other options as desired
  // the options sepcified in constructor will
  // be used as defaults
  geometry.update(s);

  // the resulting layout has metrics and bounds
  // console.log(geometry.layout.height)
  // console.log(geometry.layout.descender)

  var material = new THREE.RawShaderMaterial(createSDFShader({
    map: fontTexture,
    transparent: true,
    color,
    // color: palette[Math.floor(Math.random() * palette.length)]
    // negate: false,
    side: THREE.DoubleSide,
  }));

  const scaleFactor = 0.002 * size;

  const mesh = new THREE.Mesh(geometry, material)
  mesh.position.set(0, -geometry.layout.lineHeight * 0.001, 0);
  mesh.scale.set(scaleFactor, -scaleFactor, -scaleFactor);
  mesh.getText = () => s;
  mesh.setText = newS => {
    if (newS !== s) {
      s = newS;
      geometry.update(s);
    }
  };
  return mesh;
};
const meshes = {
  eyes: _makeCubeMesh(0xFF0000),
  head: _makeCubeMesh(0xFF8080),

  chest: _makeCubeMesh(0xFFFF00),
  leftShoulder: _makeCubeMesh(0x00FF00),
  rightShoulder: _makeCubeMesh(0x008000),
  leftUpperArm: _makeCubeMesh(0x00FFFF),
  rightUpperArm: _makeCubeMesh(0x008080),
  leftLowerArm: _makeCubeMesh(0x0000FF),
  rightLowerArm: _makeCubeMesh(0x000080),
  leftHand: _makeCubeMesh(0xFFFFFF),
  rightHand: _makeCubeMesh(0x808080),

  hips: _makeCubeMesh(0xFF0000),
  leftUpperLeg: _makeCubeMesh(0xFFFF00),
  rightUpperLeg: _makeCubeMesh(0x808000),
  leftLowerLeg: _makeCubeMesh(0x00FF00),
  rightLowerLeg: _makeCubeMesh(0x008000),
  leftFoot: _makeCubeMesh(0xFFFFFF),
  rightFoot: _makeCubeMesh(0x808080),
};
const meshDolly = new THREE.Object3D();
for (const k in meshes) {
  // meshDolly.add(meshes[k]);
}
scene.add(meshDolly);
/* scene.remove(meshes.shoulderLeft);
scene.remove(meshes.upperArmLeft);
scene.remove(meshes.lowerArmLeft);
scene.remove(meshes.handLeft);
scene.remove(meshes.shoulderRight);
scene.remove(meshes.upperArmRight);
scene.remove(meshes.lowerArmRight);
scene.remove(meshes.handRight);
scene.remove(meshes.shoulderRight);
scene.remove(meshes.upperLegRight);
scene.remove(meshes.lowerLegRight);
scene.remove(meshes.footRight); */

const teleportGeometry = new THREE.TorusBufferGeometry(0.5, 0.15, 3, 5)
  .applyMatrix(new THREE.Matrix4().makeRotationX(-(Math.PI / 2)))
  .applyMatrix(new THREE.Matrix4().makeRotationY((1 / 20) * (Math.PI * 2)));
const teleportMaterial = new THREE.MeshBasicMaterial({
  color: 0x44c2ff,
});
const _makeTeleportMesh = () => {
  const geometry = teleportGeometry;
  const material = teleportMaterial;

  const mesh = new THREE.Mesh(geometry, material);
  mesh.visible = false;
  mesh.frustumCulled = false;
  return mesh;
};
const teleportMeshes = [
  _makeTeleportMesh(),
  _makeTeleportMesh(),
];
scene.add(teleportMeshes[0]);
scene.add(teleportMeshes[1]);

const _getFileType = filename => {
  if (/\.(?:gltf|glb|vrm)$/.test(filename)) {
    return 'gltf';
  } else if (/\.fbx$/.test(filename)) {
    return 'fbx';
  } else if (/\.(?:tar\.gz|tgz|unitypackage)$/.test(filename)) {
    return 'tgz';
  } else if (/\.(?:zip)$/.test(filename)) {
    return 'zip';
  } else {
    return null;
  }
};
const _pathname2Filename = pathname => {
  const match = pathname.match(/([^\/]+)$/);
  return match && match[1];
};
const _filename2Ext = filename => {
  const match = filename.match(/\.([^\.]+)$/);
  return match ? match[1] : null;
};
const _loadModelFilesystem = async filesystem => {
  const manager = new THREE.LoadingManager();
  manager.setURLModifier(url => {
    const match = url.match(/([^\/]+)$/);
    if (match) {
      const filename = match[1];
      const file = filesystem.find(file => file.filename === filename);
      if (file) {
        url = file.url;
      } else {
        const ext = _filename2Ext(filename);
        if (ext) {
          const file = filesystem.find(file => file.ext === ext);
          if (file) {
            url = file.url;
          }
        }
      }
    }
    return url;
  });

  const modelFiles = filesystem.filter(file => /\.(?:fbx|gltf|glb)/.test(file.pathname)).map(file => {
    const pathnamePrefix = file.pathname.replace(/[^\/]+$/, '');
    const numSiblingFiles = filesystem.filter(file => file.pathname.startsWith(pathnamePrefix)).length;
    return {
      file,
      numSiblingFiles,
    };
  }).sort((a, b) => {
    const diff = b.numSiblingFiles - a.numSiblingFiles;
    if (diff !== 0) {
      return diff;
    } else {
      return +/unity/i.test(b.file.filename) - +/unity/i.test(a.file.filename);
    }
  }).map(({file}) => file);
  if (modelFiles.length > 0) {
    const modelFile = modelFiles[0];
    // console.log('got model file', modelFile);
    const modelFileUrl = modelFile.url;
    console.log(`using model file: ${modelFile.pathname}`);
    if (/\.fbx$/.test(modelFile.pathname)) {
      const model = await new Promise((accept, reject) => {
        new THREE.FBXLoader(manager).load(modelFileUrl, accept, function onprogress() {}, reject);
      });
      return model;
    } else {
      const model = await new Promise((accept, reject) => {
        new THREE.GLTFLoader(manager).load(modelFileUrl, object => {
          accept(object.scene);
        }, xhr => {}, reject);
      });
      return model;
    }
  } else {
    throw new Error('no model file in package');
  }
};
const _readAsArrayBuffer = blob => new Promise((accept, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    accept(reader.result);
  };
  reader.onerror = reject;
  reader.readAsArrayBuffer(blob);
});
const _patchModel = model => {
  model.traverse(o => {
    if (o.isMesh) {
      o.frustumCulled = false;

      if (o.material.opacity === 0) {
        o.material.opacity = 1;
      }
    }
  });
};
const _loadModelUrl = async (href, filename = href) => {
  const fileType = _getFileType(filename);
  if (fileType === 'gltf') {
    const model = await new Promise((accept, reject) => {
      new THREE.GLTFLoader().load(href, object => {
        accept(object.scene);
      }, xhr => {}, reject);
    });
    _patchModel(model);
    return model;
  } else if (fileType === 'fbx') {
    const model = await new Promise((accept, reject) => {
      new THREE.FBXLoader().load(href, accept, xhr => {}, reject);
    });
    _patchModel(model);
    return model;
  } else if (fileType === 'zip') {
    const unitypackageRes = await fetch(href);
    const blob = await unitypackageRes.blob();
    const reader = await new Promise((accept, reject) => {
      zip.createReader(new zip.BlobReader(blob), accept, reject);
    });
    const entries = await new Promise((accept, reject) => {
      reader.getEntries(accept);
    });

    const filesystem = [];
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      const pathname = entry.filename;
      const filename = _pathname2Filename(pathname);
      const ext = _filename2Ext(filename);
      const blob = await new Promise((accept, reject) => {
        entry.getData(new zip.BlobWriter('application/octet-stream'), accept, function onprogress(current, total) {});
      });
      const url = URL.createObjectURL(blob);
      filesystem.push({
        pathname,
        filename,
        ext,
        url,
      });
      // console.log('got blob', entry, blob, pathname, filename, url);
    }
    // console.log('got filesystem', filesystem);

    const model = await _loadModelFilesystem(filesystem);
    _patchModel(model);
    return model;
  } else if (fileType === 'tgz') {
    const unitypackageRes = await fetch(href);
    const arraybuffer = await unitypackageRes.arrayBuffer();
    const inflatedArrayBuffer = new Zlib.Gunzip(new Uint8Array(arraybuffer)).decompress().buffer;
    const files = await untar(inflatedArrayBuffer);
    // console.log('got files', files);
    // window.files = files;

    const filesystem = [];
    for (let j = 0; j < files.length; j++) {
      const file = files[j];
      const {name} = file;
      const match = name.match(/^([a-zA-Z0-9]+)\/pathname$/);
      if (match) {
        const pathname = new TextDecoder().decode(await _readAsArrayBuffer(file.blob));
        const id = match[1];
        const assetFileName = `${id}/asset`;
        const assetFile = files.find(file => file.name === assetFileName);
        if (assetFile) {
          const filename = _pathname2Filename(pathname);
          const url = assetFile.getBlobUrl();
          filesystem.push({
            pathname,
            filename,
            url,
          });
        }
      }
    }
    const model = await _loadModelFilesystem(filesystem);
    _patchModel(model);
    return model;
  } else {
    throw new Error(`unknown file type: ${filename} (${fileType})`);
  }
};

const _bindUploadFileButton = inputFileEl => {
  inputFileEl.addEventListener('change', async e => {
    const {files} = e.target;
    if (files.length === 1) {
      const [file] = files;
      const dataUrl = URL.createObjectURL(file);
      const model = await _loadModelUrl(dataUrl, file.name);
      _setLocalModel(model);
      // modelUrl = dataUrl;
    }

    const {parentNode} = inputFileEl;
    parentNode.removeChild(inputFileEl);
    const newInputFileEl = document.createElement('input');
    newInputFileEl.type = 'file';
    newInputFileEl.id = 'upload-file-button';
    newInputFileEl.style.display = 'none';
    parentNode.appendChild(newInputFileEl);
    _bindUploadFileButton(newInputFileEl);
  });
};
_bindUploadFileButton(document.getElementById('upload-file-button'));
window.document.addEventListener('dragover', e => {
  e.preventDefault();
});
window.document.addEventListener('drop', async e => {
  e.preventDefault();

  if (e.dataTransfer.items.length !== 1) {
    return;
  }

  for (var i = 0; i < e.dataTransfer.items.length; i++) {
    if (e.dataTransfer.items[i].kind === 'file') {
      const file = e.dataTransfer.items[i].getAsFile();
      // console.log('got file', e.dataTransfer.items[i], file);
      const dataUrl = URL.createObjectURL(file);
      const model = await _loadModelUrl(dataUrl, file.name);
      _setLocalModel(model);
      // modelUrl = dataUrl;
    }
  }
});

const renderer = new THREE.WebGLRenderer({
  // canvas: document.getElementById('canvas'),
  // alpha: true,
  antialias: true,
});
// console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
document.getElementById('iframe-wrapper').appendChild(renderer.domElement);

const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
orbitControls.screenSpacePanning = true;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const aAvatars = Array.from(document.querySelectorAll('.a-avatar'));
for (let i = 0; i < aAvatars.length; i++) {
  const aAvatar = aAvatars[i];
  aAvatar.addEventListener('click', async e => {
    e.preventDefault();

    const {href} = aAvatar;
    const model = await _loadModelUrl(href);
    _setLocalModel(model);
    modelUrl = href;
  });
}

let fontJson, fontTexture;
const fontPromise = Promise.all([
  fetch('DejaVu-sdf.json').then(res => res.json()),
  new Promise((accept, reject) => {
    new THREE.TextureLoader().load('DejaVu-sdf.png', accept);
  }),
]).then(results => {
  fontJson = results[0];
  fontTexture = results[1];
});
const buttonSize = new THREE.Vector3(1, 0.1*0.9, 0.1);
const buttonGeometry = new THREE.BoxBufferGeometry(buttonSize.x, buttonSize.y, buttonSize.z);
const colors = {
  normal: 0x5c6bc0,
  highlight: 0x303f9f,
};
const _unloadSavedHead = () => {
  rig.modelBones.Head.traverse(o => {
    o.savedPosition.copy(o.position);
    o.savedMatrixWorld.copy(o.matrixWorld);
    o.position.set(NaN, NaN, NaN);
    o.matrixWorld.set(NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN);
  });
};
const _loadSavedHead = () => {
  rig.modelBones.Head.traverse(o => {
    o.position.copy(o.savedPosition);
    o.matrixWorld.copy(o.savedMatrixWorld);
  });
};
const mirrorMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(1, 2)
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, 1, 0));
  const mesh = new THREE.Reflector(geometry, {
    clipBias: 0.003,
    textureWidth: 1024 * window.devicePixelRatio,
    textureHeight: 2048 * window.devicePixelRatio,
    color: 0x889999,
    addColor: 0x300000,
    recursion: 1,
    transparent: true,
  });
  mesh.position.set(0, 0, -1);

  const buttonMeshes = aAvatars.map((aAvatar, i) => {
    const geometry = buttonGeometry;
    const material = new THREE.MeshPhongMaterial({
      color: colors.normal,
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(-1, 2 - 0.1/2 - i*0.1, 0);
    mesh.frustumCulled = false;

    fontPromise.then(() => {
      const textMesh = _makeTextMesh(aAvatar.innerText, 0xFFFFFF);
      textMesh.position.x = -0.45;
      textMesh.position.y = -0.02;
      textMesh.position.z = 0.06;
      mesh.add(textMesh);
    });

    mesh.box = new THREE.Box3();

    return mesh;
  });
  for (let i = 0; i < buttonMeshes.length; i++) {
    mesh.add(buttonMeshes[i]);
  }
  mesh.buttonMeshes = buttonMeshes;
  mesh.update = () => {
    for (let i = 0; i < buttonMeshes.length; i++) {
      const buttonMesh = buttonMeshes[i];
      buttonMesh.box.setFromCenterAndSize(buttonMesh.getWorldPosition(new THREE.Vector3()), buttonSize.clone().multiply(buttonMesh.getWorldScale(new THREE.Vector3())));
    }
  };
  mesh.getButtonIntersectionIndex = position => {
    for (let i = 0; i < buttonMeshes.length; i++) {
      if (buttonMeshes[i].box.containsPoint(position)) {
        return i;
      }
    }
    return -1;
  };

  mesh.onBeforeRender2 = () => {
    if (rig) {
      _loadSavedHead();
      // meshDolly.visible = true;
    }
  };
  mesh.onAfterRender2 = () => {
    if (rig) {
      _unloadSavedHead();
      // meshDolly.visible = false;
    }
  };

  return mesh;
})();
scene.add(mirrorMesh);

const userHeight = 1.7;
const _getHeightFactor = rigHeight => rigHeight / userHeight;

let rig = null;
let model = null;
let modelUrl = '';
// let heightOffset = 0;
let heightFactor = 0;
const _setLocalModel = object => {
  if (rig) {
    meshDolly.remove(model);
    rig = null;
    model = null;
  }

  model = object;
  rig = new Avatar(model, {
    fingers: true,
    hair: true,
    visemes: true,
    microphoneMediaStream,
  });
  rig.modelBones.Head.traverse(o => {
    o.savedPosition = new THREE.Vector3();
    o.savedMatrixWorld = new THREE.Matrix4();
  });
  meshDolly.add(model);
  window.model = model;

  // heightOffset = userHeight - rig.height;
  heightFactor = _getHeightFactor(rig.height);
  // console.log('height factor', heightFactor);

  // scene.position.y = heightOffset;
  /* model.position.y = -heightOffset;
  meshDolly.position.y = -heightOffset; */
  scene.scale.set(1, 1, 1);
  mirrorMesh.position.z = -heightFactor;
  mirrorMesh.scale.set(1, 1, 1).multiplyScalar(heightFactor);
  for (let i = 0; i < teleportMeshes.length; i++) {
    teleportMeshes[i].scale.set(1, 1, 1).multiplyScalar(heightFactor);
  }
  scene.updateMatrixWorld();
  mirrorMesh.update();
  scene.scale.divideScalar(heightFactor);
};

const lastPresseds = [false, false];
const lastPads = [false, false];
const dateOffset = Math.floor(Math.random() * 60 * 1000);
const realDateNow = (now => () => dateOffset + now())(Date.now);
function animate(timestamp, frame, referenceSpace) {
  if (rig) {
    if (renderer.vr.enabled) {
      const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;
      vrCamera.matrixWorld.decompose(vrCamera.position, vrCamera.quaternion, vrCamera.scale);
      const {inputSources} = session;
      const gamepads = navigator.getGamepads();

      rig.inputs.hmd.position.copy(vrCamera.position).multiplyScalar(heightFactor);
      rig.inputs.hmd.quaternion.copy(vrCamera.quaternion);

      const _getGamepad = i => {
        const handedness = i === 0 ? 'left' : 'right';
        const inputSource = inputSources.find(inputSource => inputSource.handedness === handedness);
        let pose, gamepad;
        if (inputSource && (pose = frame.getPose(inputSource.targetRaySpace, referenceSpace)) && (gamepad = inputSource.gamepad || gamepads[i])) {
          const {transform} = pose;
          const {position, orientation, matrix} = transform;
          if (position) { // new WebXR api
            const p = localVector.copy(position)
              .add(cameraDolly.position)
              .multiplyScalar(heightFactor);
            const q = localQuaternion.copy(orientation);
            const pressed = gamepad.buttons[0].pressed;
            const lastPressed = lastPresseds[i];
            const pointer = gamepad.buttons[0].value;
            const grip = gamepad.buttons[1].value;
            const pad = gamepad.axes[1] <= -0.5 || gamepad.axes[3] <= -0.5;
            const padX = gamepad.axes[0] !== 0 ? gamepad.axes[0] : gamepad.axes[2];
            const padY = gamepad.axes[1] !== 0 ? gamepad.axes[1] : gamepad.axes[3];
            return {
              position: p,
              quaternion: q,
              pressed,
              lastPressed,
              pointer,
              grip,
              pad,
              padX,
              padY,
            };
          } else if (matrix) { // old WebXR api
            const p = localVector;
            const q = localQuaternion;
            const s = localVector2;
            localMatrix
              .fromArray(transform.matrix)
              .decompose(p, q, s);
            p
              .add(cameraDolly.position)
              .multiplyScalar(heightFactor);
            const pressed = gamepad.buttons[0].pressed;
            const lastPressed = lastPresseds[i];
            const pointer = gamepad.buttons[0].value;
            const grip = gamepad.buttons[1].value;
            const pad = gamepad.axes[1] <= -0.5 || gamepad.axes[3] <= -0.5;
            const padX = gamepad.axes[0] !== 0 ? gamepad.axes[0] : gamepad.axes[2];
            const padY = gamepad.axes[1] !== 0 ? gamepad.axes[1] : gamepad.axes[3];
            return {
              position: p,
              quaternion: q,
              pressed,
              lastPressed,
              pointer,
              grip,
              pad,
              padX,
              padY,
            };
          } else {
            return null;
          }
        } else {
          return null;
        }
      };
      const _updateTeleportMesh = (i, pad, lastPad, position, quaternion, padX, padY) => {
        const teleportMesh = teleportMeshes[i];
        teleportMesh.visible = false;

        if (pad) {
          localVector.copy(position);
          localEuler.setFromQuaternion(quaternion, 'YXZ');

          for (let i = 0; i < 20; i++, localVector.add(localVector2.multiplyScalar(heightFactor)), localEuler.x = Math.max(localEuler.x - Math.PI*0.07, -Math.PI/2)) {
            localRay.set(localVector, localVector2.set(0, 0, -1).applyQuaternion(localQuaternion.setFromEuler(localEuler)));
            const intersection = localRay.intersectPlane(floorPlane, localVector3);
            if (intersection && intersection.distanceTo(localRay.origin) <= heightFactor) {
              teleportMesh.position.copy(intersection);
              localEuler.setFromQuaternion(localQuaternion, 'YXZ');
              localEuler.x = 0;
              localEuler.z = 0;
              teleportMesh.quaternion.setFromEuler(localEuler);
              teleportMesh.visible = true;
              break;
            }
          }
        } else if (lastPad) {
          teleportMesh.getWorldPosition(cameraDolly.position);
        }

        if (padX !== 0 || padY !== 0) {
          const hmdEuler = localEuler.setFromQuaternion(rig.inputs.hmd.quaternion, 'YXZ');
          localEuler.x = 0;
          localEuler.z = 0;
          cameraDolly.position.add(localVector.set(padX, 0, padY).applyEuler(hmdEuler).multiplyScalar(0.03));
        }
        cameraDolly.updateMatrixWorld(true);
      };

      const lg = _getGamepad(1);
      let li = -1;
      if (lg) {
        const {position, quaternion, pressed, lastPressed, pointer, grip, pad, padX, padY} = lg;
        rig.inputs.leftGamepad.quaternion.copy(quaternion);
        rig.inputs.leftGamepad.position.copy(position);
        rig.inputs.leftGamepad.pointer = pointer;
        rig.inputs.leftGamepad.grip = grip;

        li = mirrorMesh.getButtonIntersectionIndex(position);
        if (pressed && !lastPressed) {
          if (li !== -1) {
            aAvatars[li].click();
          }
        }

        _updateTeleportMesh(0, pad, lastPads[0], position, quaternion, 0, 0);

        lastPresseds[0] = pressed;
        lastPads[0] = pad;
      }
      const rg = _getGamepad(0);
      let ri = -1;
      if (rg) {
        const {position, quaternion, pressed, lastPressed, pointer, grip, pad, padX, padY} = rg;
        rig.inputs.rightGamepad.quaternion.copy(quaternion);
        rig.inputs.rightGamepad.position.copy(position);
        rig.inputs.rightGamepad.pointer = pointer;
        rig.inputs.rightGamepad.grip = grip;

        ri = mirrorMesh.getButtonIntersectionIndex(position);
        if (pressed && !lastPressed) {
          if (ri !== -1) {
            aAvatars[ri].click();
          }
        }

        _updateTeleportMesh(1, false, false, position, quaternion, padX, padY);

        lastPresseds[1] = pressed;
        lastPads[1] = pad;
      }

      for (let i = 0; i < mirrorMesh.buttonMeshes.length; i++) {
        mirrorMesh.buttonMeshes[i].material.color.setHex((i === li || i === ri) ? colors.highlight : colors.normal);
      }
    } else {
      const positionOffset = Math.sin((realDateNow()%10000)/10000*Math.PI*2)*2;
      const positionOffset2 = -Math.sin((realDateNow()%5000)/5000*Math.PI*2)*1;
      const standFactor = rig.height - 0.1*rig.height + Math.sin((realDateNow()%2000)/2000*Math.PI*2)*0.2*rig.height;
      const rotationAngle = (realDateNow()%5000)/5000*Math.PI*2;

      // rig.inputs.hmd.position.set(positionOffset, 0.6 + standFactor, 0);
      rig.inputs.hmd.position.set(positionOffset, standFactor, positionOffset2);
      rig.inputs.hmd.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle)
        .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.sin((realDateNow()%2000)/2000*Math.PI*2)*Math.PI*0.2))
        .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.sin((realDateNow()%2000)/2000*Math.PI*2)*Math.PI*0.25));

      rig.inputs.rightGamepad.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle)
        // .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.sin((realDateNow()%5000)/5000*Math.PI*2)*Math.PI*0.6));
      rig.inputs.rightGamepad.position.set(positionOffset, rig.height*0.7 + Math.sin((realDateNow()%2000)/2000*Math.PI*2)*0.1, positionOffset2).add(
        new THREE.Vector3(-rig.shoulderWidth/2, 0, -0.2).applyQuaternion(rig.inputs.rightGamepad.quaternion)
      )/*.add(
        new THREE.Vector3(-0.1, 0, -1).normalize().multiplyScalar(rig.rightArmLength*0.4).applyQuaternion(rig.inputs.rightGamepad.quaternion)
      ); */
      rig.inputs.leftGamepad.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle);
      rig.inputs.leftGamepad.position.set(positionOffset, rig.height*0.7, positionOffset2).add(
        new THREE.Vector3(rig.shoulderWidth/2, 0, -0.2).applyQuaternion(rig.inputs.leftGamepad.quaternion)
      )/*.add(
        new THREE.Vector3(0.1, 0, -1).normalize().multiplyScalar(rig.leftArmLength*0.4).applyQuaternion(rig.inputs.leftGamepad.quaternion)
      );*/

      rig.inputs.leftGamepad.pointer = (Math.sin((Date.now()%10000)/10000*Math.PI*2) + 1) / 2;
      rig.inputs.leftGamepad.grip = (Math.sin((Date.now()%10000)/10000*Math.PI*2) + 1) / 2;

      rig.inputs.rightGamepad.pointer = (Math.sin((Date.now()%10000)/10000*Math.PI*2) + 1) / 2;
      rig.inputs.rightGamepad.grip = (Math.sin((Date.now()%10000)/10000*Math.PI*2) + 1) / 2;
    }

    rig.update();

    for (const k in meshes) {
      const mesh = meshes[k];
      const output = rig.outputs[k];
      /* if (!mesh || !output) {
        console.warn('bad k', k);
      } */
      mesh.matrix.copy(output.matrixWorld).decompose(mesh.position, mesh.quaternion, mesh.scale);
    }
  }

  for (let i = 0; i < peerConnections.length; i++) {
    const peerConnection = peerConnections[i];
    if (peerConnection.rig) {
      peerConnection.rig.update();
    }
  }

  if (rig) {
    _unloadSavedHead();
  }

  renderer.render(scene, camera);

  if (rig) {
    _loadSavedHead();
  }
}
renderer.setAnimationLoop(animate);

let session = null;
const enterXrButton = document.getElementById('enter-xr-button');
const noXrButton = document.getElementById('no-xr-button');
enterXrButton.addEventListener('click', async () => {
  session = await navigator.xr.requestSession('immersive-vr', {
    requiredFeatures: ['local-floor'],
  });
  /* if (model) {
    meshDolly.visible = false;
  } */
  cameraDolly.add(camera);
  let referenceSpace;
  let referenceSpaceType = '';
  const _loadReferenceSpace = async () => {
    const lastReferenceSpaceType = referenceSpaceType;
    try {
      referenceSpace = await session.requestReferenceSpace('local-floor');
      referenceSpaceType = 'local-floor';
    } catch (err) {
      referenceSpace = await session.requestReferenceSpace('local');
      referenceSpaceType = 'local';
    }

    if (referenceSpaceType !== lastReferenceSpaceType) {
      console.log(`referenceSpace changed to ${referenceSpaceType}`);
    }
  };
  await _loadReferenceSpace();
  const loadReferenceSpaceInterval = setInterval(_loadReferenceSpace, 1000);

  renderer.vr.setSession(session);

  session.requestAnimationFrame((timestamp, frame) => {
    const pose = frame.getViewerPose(referenceSpace);
    const viewport = session.renderState.baseLayer.getViewport(pose.views[0]);
    // const width = viewport.width;
    const height = viewport.height;
    const fullWidth = (() => {
      let result = 0;
      for (let i = 0; i < pose.views.length; i++) {
        result += session.renderState.baseLayer.getViewport(pose.views[i]).width;
      }
      return result;
    })();
    renderer.setSize(fullWidth, height);
    renderer.setPixelRatio(1);

    renderer.setAnimationLoop(null);

    renderer.vr.enabled = true;
    renderer.vr.setSession(session);
    renderer.vr.setAnimationLoop(animate);

    console.log('loaded root in XR');
  });
});

let microphoneMediaStream = null;
const enableMicButton = document.getElementById('enable-mic-button');
const disableMicButton = document.getElementById('disable-mic-button');
enableMicButton.addEventListener('click', async () => {
  try {
    microphoneMediaStream  = await navigator.mediaDevices.getUserMedia({
      audio: true,
    });

    rig.setMicrophoneMediaStream(microphoneMediaStream);
    if (channelConnection) {
      channelConnection.setMicrophoneMediaStream(microphoneMediaStream);
    }

    disableMicButton.style.display = null;
    enableMicButton.style.display = 'none';
  } catch (err) {
    console.warn(err);
  }
});
disableMicButton.addEventListener('click', async () => {
  rig.setMicrophoneMediaStream(null);
  if (channelConnection) {
    channelConnection.setMicrophoneMediaStream(null);
  }
  microphoneMediaStream.getAudioTracks().forEach(track => {
    track.stop();
  });

  microphoneMediaStream = null;
  enableMicButton.style.display = null;
  disableMicButton.style.display = 'none';

  /* try {
    await navigator.permissions.revoke({
      name: 'microphone',
    });
  } catch(err) {
    console.warn(err);
  } */
});

let channelConnection = null;
const peerConnections = [];
const channelInput = document.getElementById('channel-input');
const connectButton = document.getElementById('connect-button');
connectButton.addEventListener('click', () => {
  const channelInputValue = channelInput.value;
  const match = channelInputValue.match(/^(.+?)\/(.+?)$/);
  if (match) {
    const userName = match[1];
    const channelName = match[2];

    console.log(`connecting to ${userName}/${channelName}`);

    channelConnection = new XRChannelConnection(`wss://presence.exokit.org/?u=${encodeURIComponent(userName)}&c=${encodeURIComponent(channelName)}`, {
      microphoneMediaStream,
    });
    channelConnection.addEventListener('open', () => {
      console.log('xr channel open');
    });
    channelConnection.addEventListener('error', err => {
      console.warn('xr channel error', err);
    });
    channelConnection.addEventListener('peerconnection', e => {
      const peerConnection = e.detail;

      peerConnection.model = null;
      peerConnection.rig = null;
      peerConnection.mediaStream = null;
      let updateInterval = 0;
      peerConnection.addEventListener('open', () => {
        console.log('add peer connection', peerConnection);

        peerConnections.push(peerConnection);

        peerConnection.send(JSON.stringify({
          method: 'model',
          url: modelUrl,
        }));

        updateInterval = setInterval(() => {
          if (rig) {
            const hmd = {
              position: localVector.copy(rig.inputs.hmd.position).divideScalar(heightFactor).toArray(),
              quaternion: rig.inputs.hmd.quaternion.toArray(),
            };
            const gamepads = [
              {
                position: localVector.copy(rig.inputs.leftGamepad.position).divideScalar(heightFactor).toArray(),
                quaternion: rig.inputs.leftGamepad.quaternion.toArray(),
                pointer: rig.inputs.leftGamepad.pointer,
                grip: rig.inputs.leftGamepad.grip,
                visible: true,
              },
              {
                position: localVector.copy(rig.inputs.rightGamepad.position).divideScalar(heightFactor).toArray(),
                quaternion: rig.inputs.rightGamepad.quaternion.toArray(),
                pointer: rig.inputs.rightGamepad.pointer,
                grip: rig.inputs.rightGamepad.grip,
                visible: true,
              },
            ];
            peerConnection.update(hmd, gamepads);
          }
        }, peerPoseUpdateRate);
      });
      peerConnection.addEventListener('close', () => {
        console.log('remove peer connection', peerConnection);

        const index = peerConnections.indexOf(peerConnection);
        if (index !== -1) {
          peerConnections.splice(index, 1);
        }

        clearInterval(updateInterval);

        if (peerConnection.model) {
          scene.remove(peerConnection.model);
        }
      });
      peerConnection.addEventListener('pose', e => {
        const {rig} = peerConnection;
        if (rig) {
          const {detail: data} = e;
          const {hmd, gamepads} = data;

          rig.starts.hmd.position.copy(peerConnection.rig.inputs.hmd.position);
          rig.starts.hmd.rotation.copy(peerConnection.rig.inputs.hmd.quaternion);
          rig.starts.gamepads[0].position.copy(peerConnection.rig.inputs.leftGamepad.position);
          rig.starts.gamepads[0].rotation.copy(peerConnection.rig.inputs.leftGamepad.quaternion);
          rig.starts.gamepads[0].pointer = peerConnection.rig.inputs.leftGamepad.pointer;
          rig.starts.gamepads[0].grip = peerConnection.rig.inputs.leftGamepad.grip;
          rig.starts.gamepads[1].position.copy(peerConnection.rig.inputs.rightGamepad.position);
          rig.starts.gamepads[1].rotation.copy(peerConnection.rig.inputs.rightGamepad.quaternion);
          rig.starts.gamepads[1].pointer = peerConnection.rig.inputs.rightGamepad.pointer;
          rig.starts.gamepads[1].grip = peerConnection.rig.inputs.rightGamepad.grip;

          rig.targets.hmd.position.fromArray(hmd.position);
          rig.targets.hmd.rotation.fromArray(hmd.quaternion);
          rig.targets.gamepads[0].position.fromArray(gamepads[0].position);
          rig.targets.gamepads[0].rotation.fromArray(gamepads[0].quaternion);
          rig.targets.gamepads[0].pointer = gamepads[0].pointer;
          rig.targets.gamepads[0].grip = gamepads[0].grip;
          rig.targets.gamepads[1].position.fromArray(gamepads[1].position);
          rig.targets.gamepads[1].rotation.fromArray(gamepads[1].quaternion);
          rig.targets.gamepads[1].pointer = gamepads[1].pointer;
          rig.targets.gamepads[1].grip = gamepads[1].grip;
          rig.targets.timestamp = Date.now();
        }
      });
      peerConnection.addEventListener('mediastream', e => {
        console.log('got media stream', e.detail, e.detail.getAudioTracks());
        peerConnection.mediaStream = e.detail;
        if (peerConnection.rig) {
          peerConnection.rig.setMicrophoneMediaStream(peerConnection.mediaStream, {
            muted: false,
          });
        }
      });
      peerConnection.addEventListener('message', async e => {
        console.log('got message', e);
        const data = JSON.parse(e.data);
        const {method} = data;
        if (method === 'model') {
          const {url} = data;
          console.log('got peer model', {url});

          if (peerConnection.model) {
            scene.remove(peerConnection.model);
          }

          peerConnection.model = await _loadModelUrl(url);
          peerConnection.rig = new Avatar(peerConnection.model, {
            fingers: true,
            hair: true,
            visemes: true,
            microphoneMediaStream: peerConnection.mediaStream,
            muted: false,
          });
          scene.add(peerConnection.model);

          peerConnection.rig.starts = {
            hmd: {
              position: peerConnection.rig.inputs.hmd.position.clone(),
              rotation: peerConnection.rig.inputs.hmd.quaternion.clone(),
            },
            gamepads: [
              {
                position: peerConnection.rig.inputs.leftGamepad.position.clone(),
                rotation:  peerConnection.rig.inputs.leftGamepad.quaternion.clone(),
                pointer: peerConnection.rig.inputs.leftGamepad.pointer,
                grip: peerConnection.rig.inputs.leftGamepad.grip,
              },
              {
                position: peerConnection.rig.inputs.rightGamepad.position.clone(),
                rotation: peerConnection.rig.inputs.rightGamepad.quaternion.clone(),
                pointer: peerConnection.rig.inputs.rightGamepad.pointer,
                grip: peerConnection.rig.inputs.rightGamepad.grip,
              },
            ],
          };
          peerConnection.rig.targets = {
            hmd: {
              position: new THREE.Vector3(),
              rotation: new THREE.Quaternion(),
            },
            gamepads: [
              {
                position: new THREE.Vector3(),
                rotation: new THREE.Quaternion(),
                pointer: 0,
                grip: 0,
              },
              {
                position: new THREE.Vector3(),
                rotation: new THREE.Quaternion(),
                pointer: 0,
                grip: 0,
              },
            ],
            timestamp: Date.now(),
          };
          const heightFactor = _getHeightFactor(peerConnection.rig.height);
          peerConnection.rig.update = (_update => function update() {
            const now = Date.now();
            const {timestamp} = peerConnection.rig.targets;
            const lerpFactor = Math.min(Math.max((now - timestamp) / (peerPoseUpdateRate*2), 0), 1);  

            peerConnection.rig.inputs.hmd.quaternion.copy(peerConnection.rig.starts.hmd.rotation).slerp(peerConnection.rig.targets.hmd.rotation, lerpFactor);
            peerConnection.rig.inputs.hmd.position.copy(peerConnection.rig.starts.hmd.position).lerp(
              localVector.copy(peerConnection.rig.targets.hmd.position).multiplyScalar(heightFactor),
              lerpFactor
            );

            peerConnection.rig.inputs.leftGamepad.position.copy(peerConnection.rig.starts.gamepads[0].position).lerp(
              localVector.copy(peerConnection.rig.targets.gamepads[0].position).multiplyScalar(heightFactor),
              lerpFactor
            );
            peerConnection.rig.inputs.leftGamepad.quaternion.copy(peerConnection.rig.starts.gamepads[0].rotation).slerp(peerConnection.rig.targets.gamepads[0].rotation, lerpFactor);
            peerConnection.rig.inputs.leftGamepad.pointer = peerConnection.rig.starts.gamepads[0].pointer * (1-lerpFactor) + peerConnection.rig.targets.gamepads[0].pointer * lerpFactor;
            peerConnection.rig.inputs.leftGamepad.grip = peerConnection.rig.starts.gamepads[0].grip * (1-lerpFactor) + peerConnection.rig.targets.gamepads[0].grip * lerpFactor;

            peerConnection.rig.inputs.rightGamepad.position.copy(peerConnection.rig.starts.gamepads[1].position).lerp(
              localVector.copy(peerConnection.rig.targets.gamepads[1].position).multiplyScalar(heightFactor),
              lerpFactor
            );
            peerConnection.rig.inputs.rightGamepad.quaternion.copy(peerConnection.rig.starts.gamepads[1].rotation).slerp(peerConnection.rig.targets.gamepads[1].rotation, lerpFactor);
            peerConnection.rig.inputs.rightGamepad.pointer = peerConnection.rig.starts.gamepads[1].pointer * (1-lerpFactor) + peerConnection.rig.targets.gamepads[1].pointer * lerpFactor;
            peerConnection.rig.inputs.rightGamepad.grip = peerConnection.rig.starts.gamepads[1].grip * (1-lerpFactor) + peerConnection.rig.targets.gamepads[1].grip * lerpFactor;

            _update.apply(this, arguments);
          })(peerConnection.rig.update);
        } else {
          console.warn('invalid method', {method});
        }
      });
    });

    connectButton.style.display = 'none';
  } else {
    console.warn(`invalid user/channel: ${channelInputValue}`);
  }
});

(async () => {
  let result;
  if (navigator.xr) {
    try {
      await navigator.xr.supportsSession('immersive-vr');
      result = true;
    } catch (err) {
      console.warn(err);
      result = false;
    }
  } else {
    result = false;
  }
  if (result) {
    console.log('xr available');
    enterXrButton.style.display = null;
  } else {
    console.log('no xr');
    noXrButton.style.display = null;
  }

  /* const microphonePermission = await navigator.permissions.query({
    name: 'microphone',
  });
  if (microphonePermission.state === 'granted') {
    microphoneMediaStream  = await navigator.mediaDevices.getUserMedia({
      audio: true,
    });
    disableMicButton.style.display = null;
  } else {
    enableMicButton.style.display = null;
  } */
  enableMicButton.style.display = null;

  const url = aAvatars[0].href;
  const model = await _loadModelUrl(url);
  _setLocalModel(model);
  modelUrl = url;
})();
    </script>
  </body>
</html>
